// COMSC-210 | Lab 21 | Xiao Zhang


#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;

const int MIN_AGE = 1, MAX_AGE = 20, MIN_LS = 5, MAX_LS = 20, NUM_NAMES = 15, NUM_COLORS = 15;

class Goat {
private:
    int age;
    string name;
    string color;
    const string names[NUM_NAMES] = {"Billy", "Grumpy", "Whiskers", "Jumpy", "Nibbles",
                                     "Bucky", "Gizmo", "Shadow", "Daisy", "Cupcake",
                                     "Buddy", "Moo", "Snickers", "Coco", "Snowball"}; //generated by AI
    const string colors[NUM_COLORS] = {"White", "Black", "Brown", "Grey", "Spotted",
                                       "Yellow", "Red", "Blue", "Green", "Purple",
                                       "Orange", "Pink", "Gold", "Silver", "Mauve"};//generated by AI

public:
    // Default constructor - create a random goat
    Goat() {
        age = rand() % (MAX_AGE - MIN_AGE + 1) + MIN_AGE;
        name = names[rand() % NUM_NAMES];
        color = colors[rand() % NUM_COLORS];
    }

    // Parameterized constructor
    Goat(int a, const string& n, const string& c) : age(a), name(n), color(c) {}

    // Displays the details
    void display() const {
        cout << name << " (" << color << ", " << age << ")";
    }
};


class DoublyLinkedList {
private:
    struct Node {
        Goat goatData;
        Node* prev;
        Node* next;
        Node(const Goat& val, Node* p = nullptr, Node* n = nullptr)
            : goatData(val), prev(p), next(n) {}
    };

    Node* head;
    Node* tail;

public:
    // Constructor
    DoublyLinkedList() : head(nullptr), tail(nullptr) {}

    // Inserts a goat at the back of the list
    void push_back(const Goat& goat) {
        Node* newNode = new Node(goat);
        if (!tail) {
            head = tail = newNode;  // Empty list case
        } else {
            tail->next = newNode;
            newNode->prev = tail;
            tail = newNode;
        }
    }

    // Inserts a goat at the front of the list
    void push_front(const Goat& goat) {
        Node* newNode = new Node(goat);
        if (!head) {
            head = tail = newNode;  // Empty list case
        } else {
            newNode->next = head;
            head->prev = newNode;
            head = newNode;
        }
    }

    // Prints the list from head to tail
    void print() const {
        if (!head) {
            cout << "List is empty" << endl;
            return;
        }
        Node* current = head;
        while (current) {
            cout << endl;
            current->goatData.display();
            current = current->next;
        }
        cout << endl;
    }

    // Prints the list from tail to head
    void print_reverse() const {
        if (!tail) {
            cout << "List is empty" << endl;
            return;
        }
        Node* current = tail;
        while (current) {
            cout << endl;
            current->goatData.display();
            current = current->prev;
        }
        cout << endl;
    }

    // Destructor
    ~DoublyLinkedList() {
        while (head) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
    }
};


void generate_random_goats(DoublyLinkedList& list, int size);


int main() {
    srand(time(0));  // Seed the random number generator

    DoublyLinkedList goatList;
    int size = rand() % (MAX_LS - MIN_LS + 1) + MIN_LS;

    // Populate the list with random goats
    generate_random_goats(goatList, size);

    // Display the list forward and backward
    cout << "Forward: ";
    goatList.print();

    cout << "\nBackward: ";
    goatList.print_reverse();

    return 0;
}

// generates random goats and adds to the list
void generate_random_goats(DoublyLinkedList& list, int size) {
    for (int i = 0; i < size; ++i) {
        list.push_back(Goat());
    }
}
